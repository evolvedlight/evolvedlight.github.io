import{_ as e,c as a,o as s,a as t}from"./chunks/framework.f55bdc3d.js";const b=JSON.parse('{"title":"Creating Kerberos secured connections from Dotnet on Linux","description":"","frontmatter":{"title":"Creating Kerberos secured connections from Dotnet on Linux","date":"2023-08-05T00:00:00.000Z","author":"Stephen Brown"},"headers":[],"relativePath":"posts/dotnet-kerberos.md","filePath":"posts/dotnet-kerberos.md"}'),n={name:"posts/dotnet-kerberos.md"},o=t(`<h2 id="for-the-last-few-years-at-my-workplace-we-ve-been-using-kerberos-authentication-to-connect-to-the-on-prem-sql-server-databases-on-windows-this-just-worked-like-magic-as-the-services-ran-as-a-windows-domain-user-and-so-could-connect-to-the-database-without-any-additional-configuration-however-when-moving-to-kubernetes-and-linux-systems-this-didn-t-work-out-of-the-box" tabindex="-1">For the last few years at my workplace we&#39;ve been using Kerberos authentication to connect to the on-prem SQL Server databases. On Windows this just worked like magic, as the services ran as a Windows domain user and so could connect to the database without any additional configuration. However, when moving to Kubernetes and Linux systems, this didn&#39;t work out of the box. <a class="header-anchor" href="#for-the-last-few-years-at-my-workplace-we-ve-been-using-kerberos-authentication-to-connect-to-the-on-prem-sql-server-databases-on-windows-this-just-worked-like-magic-as-the-services-ran-as-a-windows-domain-user-and-so-could-connect-to-the-database-without-any-additional-configuration-however-when-moving-to-kubernetes-and-linux-systems-this-didn-t-work-out-of-the-box" aria-label="Permalink to &quot;For the last few years at my workplace we&#39;ve been using Kerberos authentication to connect to the on-prem SQL Server databases. On Windows this just worked like magic, as the services ran as a Windows domain user and so could connect to the database without any additional configuration. However, when moving to Kubernetes and Linux systems, this didn&#39;t work out of the box.&quot;">â€‹</a></h2><p>Our initial solution was following this <a href="https://cloud.redhat.com/blog/kerberos-sidecar-container" target="_blank" rel="noreferrer">red hat blog post</a> which details how to setup a sidecar which keeps a kerberos token valid. This worked for a number of years but did have some problems:</p><ul><li>We ran 100+ containers and each needed a sidecar - this cost a few gigabytes of memory and some CPU allowance</li><li>When the token was being refreshed, it was not available for a few milliseconds</li><li>It was extra hassle and created slightly larger deployments and more complex Deployment configs.</li></ul><p>When investigating a seperate issue (dotnet 7 caused some transient kerberos faults) we realised that actually the whole sidecar approach was completely unneccessary! This post will give the minimum you actually need to call Keberos services from Linux</p><ol><li>You&#39;ll need to add the keberos tools to your docker image. Maybe you have a base image you share, maybe not. For alpine images:</li></ol><p><code>RUN apk add --no-cache krb5</code></p><ol start="2"><li>You&#39;ll need to have a krb5 configuration that points to your domain controller. Microsoft has an <a href="https://learn.microsoft.com/en-us/sql/connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server?view=sql-server-ver16#creating-a-kerberos-configuration-file" target="_blank" rel="noreferrer">example</a></li></ol><p>For example, ours looks like this:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">[logging]</span></span>
<span class="line"><span style="color:#A6ACCD;">default</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[libdefaults]</span></span>
<span class="line"><span style="color:#A6ACCD;">...standard things here</span></span>
<span class="line"><span style="color:#A6ACCD;">default_client_keytab_name=/krb5/client.keytab</span></span>
<span class="line"><span style="color:#A6ACCD;">default_keytab_name=/krb5/krb5.keytab</span></span>
<span class="line"><span style="color:#A6ACCD;">default_ccache_name=FILE:/dev/shm/ccache</span></span>
<span class="line"><span style="color:#A6ACCD;">default_realm = EXAMPLE.COM</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">[realms]</span></span>
<span class="line"><span style="color:#A6ACCD;">EXAMPLE.COM = {</span></span>
<span class="line"><span style="color:#A6ACCD;">    kdc = ADS.EXAMPLE.COM:88</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>You can then add this to the docker image like</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">RUN mkdir /krb5 &amp;&amp; mkdir /customkrb5</span></span>
<span class="line"><span style="color:#A6ACCD;">COPY krb5.conf /customkrb5/krb5.conf</span></span>
<span class="line"><span style="color:#A6ACCD;">ENV KRB5_CONFIG=/customkrb5/krb5.conf</span></span></code></pre></div><p>We put it in a custom folder as some container systems have the limitation that mounting a directory overrides all files in that directory (we&#39;ll do this later)</p><ol start="3"><li><p>You then need a keytab added to the image. You will probably want this done at runtime. Get a keytab (maybe off your AD system administrators, maybe you create it yourself with ktutil) and make sure this ends up at /krb5/client.keytab. We use kubernetes secrets and volume mounts for this</p></li><li><p>Connect to the database using <code>Integrated Security=true</code>. This should now just work. You can check by calling <code>klist</code> inside the container to see that it has a ticket</p></li></ol>`,13),r=[o];function i(l,c,d,p,h,u){return s(),a("div",null,r)}const k=e(n,[["render",i]]);export{b as __pageData,k as default};
